<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: 关于es6编码规范
ES6编程风格1. 块级作用域
2. 字符串
3. 解构赋值
4. 对象
5. 数组
6. 函数
7. Map结构
8. Class
9. 模块
10. ESLint的使用
块级作用域
let取代var，let完全可以取代var，因为其没有副作用。
&amp;apos;use strict&amp;apos;;

for (let i = 0; i &amp;lt; 10; i++)">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/03/12/关于es6编码规范/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: 关于es6编码规范
ES6编程风格1. 块级作用域
2. 字符串
3. 解构赋值
4. 对象
5. 数组
6. 函数
7. Map结构
8. Class
9. 模块
10. ESLint的使用
块级作用域
let取代var，let完全可以取代var，因为其没有副作用。
&amp;apos;use strict&amp;apos;;

for (let i = 0; i &amp;lt; 10; i++)">
<meta property="og:updated_time" content="2017-03-12T14:32:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="title: 关于es6编码规范
ES6编程风格1. 块级作用域
2. 字符串
3. 解构赋值
4. 对象
5. 数组
6. 函数
7. Map结构
8. Class
9. 模块
10. ESLint的使用
块级作用域
let取代var，let完全可以取代var，因为其没有副作用。
&amp;apos;use strict&amp;apos;;

for (let i = 0; i &amp;lt; 10; i++)">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-关于es6编码规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/12/关于es6编码规范/" class="article-date">
  <time datetime="2017-03-12T14:27:33.000Z" itemprop="datePublished">2017-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 关于es6编码规范</p>
<h2 id="ES6编程风格"><a href="#ES6编程风格" class="headerlink" title="ES6编程风格"></a>ES6编程风格</h2><pre><code>1. 块级作用域
2. 字符串
3. 解构赋值
4. 对象
5. 数组
6. 函数
7. Map结构
8. Class
9. 模块
10. ESLint的使用
</code></pre><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><ol>
<li><p>let取代var，<code>let</code>完全可以取代<code>var</code>，因为其没有副作用。</p>
<pre><code>&apos;use strict&apos;;

for (let i = 0; i &lt; 10; i++) {
  console.log(i);
}        
</code></pre></li>
<li><p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<pre><code>const [a, b, c] = [1, 2, 3];        
</code></pre></li>
</ol>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol>
<li><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<pre><code>const a = &apos;foobar&apos;;
const b = `foo${a}bar`;
</code></pre></li>
</ol>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><ol>
<li><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<pre><code>const arr = [1, 2, 3, 4];
//bad
const first = arr[0];
const second = arr[1];
//good
const [first, second] = arr;
</code></pre></li>
<li><p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<pre><code>// good
function getName(obj){
    const {firstName, lastName} = obj;
}
// best
function getName({firstName, lastName}){}
</code></pre></li>
<li><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<pre><code>// bad
function processInput(input){
    return [left, right, top, bottom];
}
// good
function processInput(input){
    return {left, right, top, bottom};
}
</code></pre></li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol>
<li><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<pre><code>const a = {k1: v1, k2: v2};
const b = {
    k1: v1,
    k2: v2,
};
</code></pre></li>
<li><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<pre><code>const a = {};
Object.assign(a, {x: 3});
// good
const a = {x: null};
a.x = 3;
</code></pre></li>
<li><p>对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>
<pre><code>const atom = {
    value: 1,
    addValue(value){
        return atom.value;
    },
};
</code></pre></li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol>
<li><p>使用扩展运算符（…）拷贝数组。</p>
<pre><code>const arr = [1, 2, 3, 4];
//good
const items = [...arr];
</code></pre></li>
<li><p>使用<code>Array.from</code>方法，将类似数组的对象转为数组。</p>
<pre><code>const foo = document.querySelectorAll(&apos;.foo&apos;);
const node = Array.from(foo);
</code></pre></li>
</ol>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol>
<li><p>立即执行函数可以写成箭头函数的形式。</p>
<pre><code>(() =&gt; {
    console.log(&apos;aaa&apos;);
})();
</code></pre></li>
<li><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了<code>this</code>。</p>
<pre><code>//good
[1, 2, 3].map((x) =&gt; {
    return x * x;
});
//best
[1, 2, 3].map(x =&gt; x * x);
</code></pre></li>
<li><p>箭头函数取代<code>Function.prototype.bind</code>，不应再用<code>self</code>/<code>_this</code>/<code>that</code>绑定<code>this</code>。简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>
<pre><code>//acceptable
const bound = method.bind(this);
//best
const bound = (...params) =&gt; method.apply(this, params);
</code></pre></li>
<li><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<pre><code>//bad
function divide(a, b, option = false){}
//good
function divide(a, b, {option = false} = {}){}
</code></pre></li>
<li><p>不要在函数体内使用<code>arguments</code>变量，使用<code>rest</code>运算符（…）代替。<code>arguments</code>是一个类似数组的对象，而<code>rest</code>运算符可以提供一个真正的数组。</p>
<pre><code>function concat(...args){
    return args.join(&apos;&apos;);
}
</code></pre></li>
<li><p>使用默认值语法设置函数参数的默认值。</p>
<pre><code>//bad
function handle(option){
    option = option || {};
}
//good
function handle(option = {}){}
</code></pre></li>
</ol>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><ol>
<li><p>注意区分<code>Object</code>和<code>Map</code>，只有模拟现实世界的实体对象时，才使用<code>Object</code>。如果只是需要<code>key: value</code>的数据结构，使用<code>Map</code>结构。因为<code>Map</code>有内建的遍历机制。</p>
<pre><code>let map = new Map(arr);
for (let key of map.keys()) {
  console.log(key);
}
for (let value of map.values()) {
  console.log(value);
}
for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
</code></pre></li>
</ol>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><ol>
<li><p>总是用<code>Class</code>，取代需要<code>prototype</code>的操作。因为<code>Class</code>的写法更简洁，更易于理解。</p>
<pre><code>//bad 
function Queue(contents = []){
    this._queue = [...contents];
}
Queue.prototype.pop = function(){
    const value = this._queue[0];
    this._queue.splice(0,1);
    return value;
}

//good
class Queue{
    constructor(contents = []){
        this._queue = [...contents];
    }
    pop(){
        const value = this._queue[0];
        this._queue.splice(0, 1);
        return value;
    }
}
</code></pre></li>
<li><p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p>
<pre><code>//bad
const inherits = require(&apos;inherits&apos;);
function PeekQueue(contents){
    Queue.apply(this, contents);
}
inherits(PeekQueue, Queue);
PeekQueue.prototype.peek = function(){
    return this._queue[0];
}
//good
class PeekQueue extends Queue{
    peek(){
        return this._queue[0];
    }
}
</code></pre></li>
</ol>
<h4 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h4><ol>
<li><p>Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>
<pre><code>//bad
const moduleA = require(&apos;moduleA&apos;);
//good
import {func1, func2} from &apos;moduleA&apos;;
</code></pre></li>
<li><p>使用<code>export</code>取代<code>module.exports</code>。<br>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。</p>
<pre><code>//commonJSx写法
var React = require(&apos;react&apos;);
var Breadcrumbs = React.createClass({
    render(){
        return &lt;nav /&gt;;
    }
});
module.exports = Breadcrumbs;
//es6写法
import React from &apos;react&apos;;
const Breadcrumbs = React.createClass({
    render(){
        return &lt;nav /&gt;;
    }
});
export default Breadcrumbs
</code></pre></li>
<li><p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（<code>export default</code>）。</p>
</li>
</ol>
<pre><code>// bad
import * as myObject &apos;./importModule&apos;;
// good
import myObject from &apos;./importModule&apos;;
</code></pre><ol>
<li><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<pre><code>function makeStyleGuide() {
}
export default makeStyleGuide;
</code></pre></li>
<li><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<pre><code>const StyleGuide = {
  es6: {
  }
};
export default StyleGuide;
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/12/关于es6编码规范/" data-id="cj06s9tvi000108i049sj0dfa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/03/12/object/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/12/关于es6编码规范/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/12/object/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>